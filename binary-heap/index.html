<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes maximum-scale=2.2 minimum-scale=1.0">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="../media/css/style.css">

    <script src="../media/js/libraries/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>Algoritmy a Datové Struktury v JS - Binary Heap</title>
</head>
<body>
    <div class="page">
        <header class="header">
            <div class="header__content">
                <h2 class="header__heading">Algoritmy a Datové Struktury v JS</h2>
                <nav class="header__navigation">
                    <ul>
                        <li><a class="header__navigation-link" href="../">úvod</a></li>
                        <li><a class="header__navigation-link header__navigation-link--active" href="../big-o-notation/">tutoriál</a></li>
                        <li><a class="header__navigation-link" href="../prehled/">přehled</a></li>
                    </ul>
                </nav>
            </div>
        </header>
        <div class="heading-section">
            Binary Heap
        </div>
        <div class="article-page">
            <div class="article-page__content">
                <main class="article-page__main-side">
                    <h1 class="heading-primary u-mb-medium">Binary Heap</h1>
                    <hr class="horizontal-rule u-mb-medium">
                    <p class="paragraph u-mb-medium">V této části si ukážeme Binary Heap. Tato datová struktura patří do Tree kategorie jménem Heap. Je to jen další druh stromové datové struktury. Co všechno za datové struktury v kategorii Heap existuje si můžete prohlédnout v <a href="https://en.wikipedia.org/wiki/List_of_data_structures#Heaps" target="_blank" class="anchor">tomto seznamu</a>.</p>
                    <h2 class="heading-secondary u-mb-tiny">Co je to Binary Heap</h2>
                    <p class="paragraph u-mb-small">Binary Heap je datová struktura podobná Binary Search Tree. Narozdíl od něj má ale trochu jiná pravidla. Binary Heap se rozděluje na dva typy: Max Binary Heap a Min Binary Heap. V Max Binary Heap mají potomci menší hodnotu než jejich předci, a v Min Binary Heap mají potomci větší hodnotu než jejich předci. V Binary Heap mezi potomky neexistují žádné podmínky jako tomu je u Binary Search Tree. Všechny node uchovávají tolik potomků, kolik jen mohou a nejdříve se zaplňují potomci nalevo. Než se začnou přidávat potomci na další úroveň, tak se nejdříve musí zaplnit stávající. Co přesně tím myslím potom uvidíte v ukázce.</p>
                    <p class="paragraph u-mb-medium">Binary Heap se používá pro implementování Priority Queue, což je velmi často používaná datová struktura. Také se používá pro algoritmy sloužící pro procházení graphů.</p>
                    <h2 class="heading-secondary u-mb-tiny">Jakým způsobem jsou v Binary Heap uložená data</h2>
                    <p class="paragraph u-mb-small">U Binary Search Tree jsme hodnoty ukládali v objektech, vytvořených pomocí třídy Node. U Binary Heap bychom to tak mohli také udělat, ale máme lepší možnost. K ukládání hodnot v Binary Heap můžeme použít pole.</p>
                    <p class="paragraph u-mb-small">Pokud budeme hodnoty v Binary Heap ukládat pomocí pole, tak v tom musíme mít nějaký systém. Hodnoty musí být v poli uložené v nějakém logickém pořadí. Také musíme mít nějaký způsob, jak v poli pro jednotlivé hodnoty budeme získávat potomky a předky.</p>
                    <p class="paragraph u-mb-small">Hodnoty jsou v poli seřazené tímto způsobem: první hodnota v poli je root a další dvě hodnoty v poli jsou její potomci. Pro druhou hodnotu v poli (na indexu 1) jsou potomci na indexu 3 a 4, pro třetí hodnotu v poli (na indexu 2) jsou potomci na indexu 5 a 6, a tak to stále pokračuje. Následující ukázka to vizuálně ukazuje.</p>
                    <div class="code-box u-mb-small">
                        <div class="code-box__array">
                            <div class="array">
                                <div class="array__bracket array__bracket--first">[</div><div class="array__item-container"><div class="array__item">41</div><div class="array__item array__item--red">39</div><div class="array__item array__item--red">33</div><div class="array__item array__item--yellow">18</div><div class="array__item array__item--yellow">27</div><div class="array__item array__item--blue">12</div></div><div class="array__bracket array__bracket--last">]</div>
                            </div>
                        </div>
                        <div class="code-box__tree code-box__tree--smaller-height">
                            <div class="tree">
                                <div class="tree__node tree__node--root">
                                    <div class="tree__node-circle tree__node-circle--green"><span>41</span></div>
                                    <div class="tree__node tree__left-child tree__left-child--double-space">
                                        <div class="tree__node-circle tree__node-circle--red"><span>39</span></div>
                                        <div class="tree__node tree__left-child">
                                            <div class="tree__node-circle tree__node-circle--yellow"><span>18</span></div>
                                        </div>
                                        <div class="tree__node tree__right-child">
                                            <div class="tree__node-circle tree__node-circle--yellow"><span>27</span></div>
                                        </div>
                                    </div>
                                    <div class="tree__node tree__right-child tree__right-child--double-space">
                                        <div class="tree__node-circle tree__node-circle--red"><span>33</span></div>
                                        <div class="tree__node tree__left-child">
                                            <div class="tree__node-circle tree__node-circle--blue"><span>12</span></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <p class="paragraph u-mb-small">Pro každou hodnotu v poli musíme být schopni získat její potomky a předka. Budeme to potřebovat v metodách, až si Binary Heap zkusíme vytvořit. Existují k tomu tyto vzorce (n představuje index hodnoty, pro kterou vzorec používáme):</p>
                    <ul class="unordered-list u-mb-medium">
                        <li><b>získání prvního (levého) potomka: </b>2n+1</li>
                        <li><b>získání druhého (pravého) potomka: </b>2n+2</li>
                        <li><b>získání předka: </b>(n-1)/2 (bez desetinné části, chceme index)</li>
                    </ul>
                    <h2 class="heading-secondary u-mb-tiny">Vytvoření základu Max Binary Heap</h2>
                    <p class="paragraph u-mb-small">Binary Heap může být typu Max nebo Min. V tomto tutoriálu si zkusíme vytvořit Max Binary Heap. Každý potomek tedy bude obsahovat menší hodnotu než jeho předek. Pokud víme jak vytvořit Max Binary Heap, tak je jednoduché předělat jej na Min Binary Heap, proto si teď zkusíme vytvořit jen jeden typ.</p>
                    <p class="paragraph u-mb-small">Pro Max Binary Heap si vytvoříme třídu, která bude obsahovat pole, do kterého si později budeme ukládat hodnoty. Nic víc nepotřebujeme, později si do ní přidáme metody.</p>
                    <div class="code-box u-mb-medium">
                        <pre class="code-box__code"><code>// třída pro Max Binary Heap
class MaxBinaryHeap {
    constructor() {
        this.values = [];
    }
}</code></pre>
                    </div>
                    <h2 class="heading-secondary u-mb-tiny">Metoda insert</h2>
                    <p class="paragraph u-mb-small">Pro přidání hodnoty do Binary Heap si vytvoříme metodu insert. Tato metoda přidá hodnotu na konec pole a zavolá metodu bubbleUp, která se postará o to, aby se naposledy vložená hodnota umístila v poli na správné místo. U Max Binary Heap platí, že potomci mají vždy menší hodnotu než jejich předek. Metoda bubbleUp tedy zajišťuje, že to tak bude i po vložení hodnoty na konec pole.</p>
                    <div data-interactive-example-id="1" class="code-box u-mb-medium">
                        <div class="code-box__header">
                            <div class="code-box__icon">
                                <svg>
                                    <use xlink:href="../media/img/icon-sprite.svg#icon-cogs"></use>
                                </svg>
                            </div>
                            <div class="code-box__buttons-container">
                                <button class="code-box__button code-box__button--move"
                                    data-interactive-example-move-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-forward3"></use>
                                    </svg>
                                </button>
                                <select class="code-box__speed-input" data-interactive-example-speed-input="true">
                                    <option value="0.25">0.25</option>
                                    <option value="0.5">0.5</option>
                                    <option value="0.75">0.75</option>
                                    <option selected value="1">1</option>
                                    <option value="1.25">1.25</option>
                                    <option value="1.5">1.5</option>
                                    <option value="1.75">1.75</option>
                                </select>
                                <button class="code-box__button" data-interactive-example-play-button="true">
                                    <span>
                                        <svg>
                                            <use xlink:href="../media/img/icon-sprite.svg#icon-play3"></use>
                                        </svg>
                                    </span>
                                </button>
                                <button class="code-box__button code-box__button--reset"
                                    data-interactive-example-reset-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-loop2"></use>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <pre id="code-1" class="code-box__code code-box__code--max-height"><code>class MaxBinaryHeap {
    /* ... */

    // metoda pro přidání hodnoty do Binary Heap
    insert(element) {
        // hodnota se vloží na konec pole values
        this.values.push(element);
        // zavolání metody bubbleUp, která umístí naposledy vloženou hodnotu na správné místo (aby byl předek vždy větší než jeho potomci)
        this.bubbleUp();
    }

    // tato metoda umístí naposledy vloženou hodnotu na správné místo (aby byl předek vždy větší než jeho potomci)
    bubbleUp() {
        // získání indexu poslední položky v poli
        let idx = this.values.length-1;

        // tento cyklus bude probíhat tak dlouho, dokud bude index idx větší než 0
        while (idx &gt; 0) {
            // získání indexu předka, hodnoty na indexu idx
            const parentIdx = Math.trunc((idx-1)/2);

            // pokud je hodnota na indexu idx menší než její předek, tak se hodnota zařadila na správné místo a cyklus může skončit
            if (this.values[idx] &lt;= this.values[parentIdx]) break;

            // vyměnění hodnoty mezi indexy parentIdx a idx
            const parent = this.values[parentIdx];
            this.values[parentIdx] = this.values[idx];
            this.values[idx] = parent;

            // změnění indexu idx na předka hodnoty, na kterou momentálně index idx ukazuje
            idx = parentIdx;
        }
    }
}

// vytvoření Max Binary Heap
const heap = new MaxBinaryHeap();

// vložení hodnot do Max Binary Heap
heap.insert(39);
heap.insert(41);
heap.insert(33);
heap.insert(52);
heap.insert(15);
heap.insert(43);
heap.insert(55);</code></pre>
                        <div class="code-box__array">
                            <div id="visual-array-insert" class="array array--bigger-top-padding">
                                <div class="array__variables"><div id="variable-insert-parent" class="array__variable"><span>parent: </span><span>0</span></div></div>
                                <div class="array__bracket array__bracket--first">[</div><div class="array__item-container"></div><div class="array__bracket array__bracket--last">]</div>
                                <div id="insert-idx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">idx</div>
                                </div>
                                <div id="insert-parentIdx" class="array__pointer">
                                    <div class="array__pointer-label">parentIdx</div>
                                </div>
                            </div>
                        </div>
                        <div class="code-box__tree code-box__tree--smaller-height-with-additional-space-for-pointer">
                            <div id="binary-heap-1" class="tree"></div>
                        </div>
                    </div>
                    <h2 class="heading-secondary u-mb-tiny">Metoda extractMax</h2>
                    <p class="paragraph u-mb-small">Jako druhou metodu si pro naši MaxBinaryHeap třídu vytvoříme metodu extractMax. Tato metoda bude sloužit k odstranění a získání root hodnoty z Binary Heap.</p>
                    <p class="paragraph u-mb-small">Metoda extractMax odstraní z pole values poslední položku a její hodnotu nastaví první položce pole. Po této operaci se zavolá metoda sinkDown, která zajistí, že se první (root) hodnota pole přemístí na takové místo, aby potomci v Binary Heap měli vždy menší hodnotu než jejich předek.</p>
                    <div data-interactive-example-id="2" class="code-box u-mb-small">
                        <div class="code-box__header">
                            <div class="code-box__icon">
                                <svg>
                                    <use xlink:href="../media/img/icon-sprite.svg#icon-cogs"></use>
                                </svg>
                            </div>
                            <div class="code-box__buttons-container">
                                <button class="code-box__button code-box__button--move"
                                    data-interactive-example-move-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-forward3"></use>
                                    </svg>
                                </button>
                                <select class="code-box__speed-input" data-interactive-example-speed-input="true">
                                    <option value="0.25">0.25</option>
                                    <option value="0.5">0.5</option>
                                    <option value="0.75">0.75</option>
                                    <option selected value="1">1</option>
                                    <option value="1.25">1.25</option>
                                    <option value="1.5">1.5</option>
                                    <option value="1.75">1.75</option>
                                </select>
                                <button class="code-box__button" data-interactive-example-play-button="true">
                                    <span>
                                        <svg>
                                            <use xlink:href="../media/img/icon-sprite.svg#icon-play3"></use>
                                        </svg>
                                    </span>
                                </button>
                                <button class="code-box__button code-box__button--reset"
                                    data-interactive-example-reset-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-loop2"></use>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <pre id="code-2" class="code-box__code code-box__code--max-height"><code>class MaxBinaryHeap {
    /* ... */

    // metoda pro odstranění a získání root hodnoty z Binary Heap
    extractMax() {
        // uložení první (root) hodnoty z pole values do proměnné max
        const max = this.values[0];
        // získání a odstranění poslední hodnoty z pole values
        const end = this.values.pop();
        // pokud pole values není prázdné, tak se první (root) položka pole nastaví na hodnotu odstraněné položky
        if (this.values.length &gt; 0) {
            this.values[0] = end;
            // zavolání metody sinkDown, která přemístí novou root hodnotu na správné místo v poli
            this.sinkDown();
        }
        // vrácení odstraněné hodnoty
        return max;
    }

    // tato metoda přemístí první (root) hodnotu v poli values na správné místo (aby byl předek vždy větší než jeho potomci)
    sinkDown() {
        // proměnná idx bude uchovávat index přemisťované hodnoty (první (root) položky pole values)
        let idx = 0;
        // získání délky pole values
        const length = this.values.length;
        // uložení hodnoty první (root) položky pole values
        const element = this.values[0];

        // tento cyklus bude probíhat tak dlouho, dokud se první hodnota v poli values nepřemístí na takové místo, aby byl v Binary Heap předek vždy větší než jeho potomci
        while (true) {
            // získání indexů potomků přemisťované hodnoty
            let leftChildIdx = 2 * idx + 1;
            let rightChildIdx = 2 * idx + 2;
            // do těchto proměnných se později uloží hodnoty potomků
            let leftChild, rightChild;
            // tato proměnná bude později určovat index potomka přemisťované hodnoty, se kterým se bude vyměňovat
            let swap = null;

            // pokud má přemisťovaná hodnota prvního (levého) potomka
            if (leftChildIdx &lt; length) {
                // uložení hodnoty prvního (levého) potomka
                leftChild = this.values[leftChildIdx];
                // pokud je potomek větší než předek (přemisťovaná hodnota), tak se proměnná swap nastaví na jeho index
                if (leftChild &gt; element) {
                    swap = leftChildIdx;
                }
            }
            // pokud má přemisťovaná hodnota druhého (pravého) potomka
            if (rightChildIdx &lt; length) {
                // uložení hodnoty pravého potomka
                rightChild = this.values[rightChildIdx];
                // pokud je pravý potomek větší než předek a levý potomek, tak se proměnná swap nastaví na jeho index
                if (
                    (swap === null && rightChild &gt; element) ||
                    (swap !== null && rightChild &gt; leftChild)
                ) {
                    swap = rightChildIdx;
                }
            }

            // pokud se přemisťovaná hodnota nemá měnit se svým potomkem, tak se hodnota umístila na správné místo a cyklus může skončit
            if (swap === null) break;
            // prohození přemisťované hodnoty s jejím potomkem
            this.values[idx] = this.values[swap];
            this.values[swap] = element;
            // index idx již neukazuje na přemisťovanou hodnotu, tento kód to napraví
            idx = swap;
        }
    }
}

// vytvoření Max Binary Heap
const heap = new MaxBinaryHeap();

// vložení hodnot do Max Binary Heap
heap.insert(39);
heap.insert(41);
heap.insert(33);
heap.insert(52);
heap.insert(15);
heap.insert(43);
heap.insert(55);

// odstranění první (root) hodnoty z Max Binary Heap
heap.extractMax();
heap.extractMax();
heap.extractMax();</code></pre>
                        <div class="code-box__array">
                            <div id="visual-array-extractMax" class="array array--bigger-top-padding">
                                <div class="array__variables" style="position: relative;"><span style="white-space: nowrap; position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);"><div id="variable-extractMax-max" class="array__variable"><span>max: </span><span>0</span></div><div id="variable-extractMax-end" class="array__variable"><span>end: </span><span>0</span></div><div id="variable-extractMax-element" class="array__variable"><span>element: </span><span>0</span></div><div id="variable-extractMax-leftChild" class="array__variable"><span>leftChild: </span><span>undefined</span></div><div id="variable-extractMax-rightChild" class="array__variable"><span>rightChild: </span><span>undefined</span></div><div id="variable-extractMax-swap" class="array__variable"><span>swap: </span><span>null</span></div></span></div>
                                <div class="array__bracket array__bracket--first">[</div><div class="array__item-container"></div><div class="array__bracket array__bracket--last">]</div>
                                <div id="extractMax-idx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">idx</div>
                                </div>
                                <div id="extractMax-leftChildIdx" class="array__pointer">
                                    <div class="array__pointer-label">leftChildIdx</div>
                                </div>
                                <div id="extractMax-rightChildIdx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">rightChildIdx</div>
                                </div>
                            </div>
                        </div>
                        <div class="code-box__tree code-box__tree--smaller-height-with-additional-space-for-pointer">
                            <div id="binary-heap-2" class="tree"></div>
                        </div>
                    </div>
                    <p class="paragraph u-mb-medium">Více metod si již do naší MaxBinaryHeap třídy přidávat nebudeme. Ty hlavní jsme si ukázali a snad jste díky nim pochopili, jak Binary Heap funguje. Pokud byste potřebovali nějaké další, tak si myslím že byste si je asi zvládli vytvořit sami. Teď si ukážeme, jak můžeme Binary Heap použít pro implementování Priority Queue.</p>
                    <h2 class="heading-secondary u-mb-tiny">Priority Queue</h2>
                    <p class="paragraph u-mb-small">Binary Heap se často používá pro vytvoření Priority Queue. Jde o datovou strukturu, ve které má každá položka nějakou prioritu. Priority Queue se podobá Queue, kterou jsme si ukazovali v části <a href="../stack-a-queue/" class="anchor">Stack a Queue</a>. Rozdíl je v tom, že v Priority Queue mají položky přiřazenou prioritu a podle toho se uvnitř Priority Queue zařazují.</p>
                    <p class="paragraph u-mb-medium">Priority Queue si můžeme například představit jako frontu lidí na nějaké pohotovosti v nemocnici. Pokud jako první přijde pacient s horečkou a jako druhý přijde pacient s postřelenou rukou, tak pacient s postřelenou rukou dostane vyšší prioritu a dostane se na řadu dříve.</p>
                    <h2 class="heading-secondary u-mb-tiny">Vytvoření základu Priority Queue</h2>
                    <p class="paragraph u-mb-small">Pro Priority Queue si vytvoříme třídu, která bude stejně jako naše třída pro Max Binary Heap, obsahovat jen pole values, do kterého se budou ukládat položky. Později si do ní přidáme metodu enqueue pro přidání položky a metodu dequeue pro odstranění a získání položky. Namísto hodnot se budou v Priority Queue do pole values ukládat nodes. Takže si pro ně musíme také vytvořit třídu. Node bude obsahovat uchovávanou hodnotu a také prioritu, která bude určovat, kdy se položka dostane na řadu.</p>
                    <div class="code-box u-mb-medium">
                        <pre class="code-box__code"><code>// třída pro node
class Node {
    constructor(value, priority) {
        this.value = value;
        this.priority = priority;
    }
}

// třída pro Priority Queue
class PriorityQueue {
    constructor() {
        this.values = [];
    }
}</code></pre>
                    </div>
                    <h2 class="heading-secondary u-mb-tiny">Metoda enqueue</h2>
                    <p class="paragraph u-mb-small">Pro přidání položky do Priority Queue si vytvoříme metodu enqueue. Bude stejná jako metoda insert, kterou jsme si vytvořili pro Max Binary Heap. Narozdíl od něj se ale do pole values bude ukládat nová node.</p>
                    <p class="paragraph u-mb-small">Metoda bubbleUp bude také skoro stejná jako metoda bubbleUp, kterou jsme si vytvořili pro Max Binary Heap. Jediný rozdíl bude v tom, že se bude porovnávat priorita položek namísto jejich hodnot.</p>
                    <div data-interactive-example-id="3" class="code-box u-mb-medium">
                        <div class="code-box__header">
                            <div class="code-box__icon">
                                <svg>
                                    <use xlink:href="../media/img/icon-sprite.svg#icon-cogs"></use>
                                </svg>
                            </div>
                            <div class="code-box__buttons-container">
                                <button class="code-box__button code-box__button--move"
                                    data-interactive-example-move-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-forward3"></use>
                                    </svg>
                                </button>
                                <select class="code-box__speed-input" data-interactive-example-speed-input="true">
                                    <option value="0.25">0.25</option>
                                    <option value="0.5">0.5</option>
                                    <option value="0.75">0.75</option>
                                    <option selected value="1">1</option>
                                    <option value="1.25">1.25</option>
                                    <option value="1.5">1.5</option>
                                    <option value="1.75">1.75</option>
                                </select>
                                <button class="code-box__button" data-interactive-example-play-button="true">
                                    <span>
                                        <svg>
                                            <use xlink:href="../media/img/icon-sprite.svg#icon-play3"></use>
                                        </svg>
                                    </span>
                                </button>
                                <button class="code-box__button code-box__button--reset"
                                    data-interactive-example-reset-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-loop2"></use>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <pre id="code-3" class="code-box__code code-box__code--max-height"><code>class PriorityQueue {
    /* ... */

    // metoda pro přidání položky do Priority Queue
    enqueue(value, priority) {
        // přidání nové node na konec pole values
        this.values.push(new Node(value, priority));
        // zavolání metody bubbleUp, která umístí naposledy vloženou node na správné místo (aby měl předek vždy větší prioritu než jeho potomci)
        this.bubbleUp();
    }

    // tato metoda umístí naposledy vloženou hodnotu na správné místo (aby měl předek vždy větší prioritu než jeho potomci)
    bubbleUp() {
        let idx = this.values.length-1;

        while (idx &gt; 0) {
            const parentIdx = Math.trunc((idx-1)/2);

            // v Priority Queue porovnáváme priority položek, jejich hodnoty ne
            if (this.values[idx].priority &lt;= this.values[parentIdx].priority) break;

            const parent = this.values[parentIdx];
            this.values[parentIdx] = this.values[idx];
            this.values[idx] = parent;

            idx = parentIdx;
        }
    }
}

// vytvoření Priority Queue
const queue = new PriorityQueue();

// vložení položek do Priority Queue
queue.enqueue(45, 3);
queue.enqueue(23, 4);
queue.enqueue(33, 2);
queue.enqueue(46, 6);
queue.enqueue(18, 2);
queue.enqueue(14, 7);
queue.enqueue(22, 1);</code></pre>
                        <div class="code-box__array">
                            <div id="visual-array-enqueue" class="array">
                                <div class="array__bracket array__bracket--first">[</div><div class="array__item-container"></div><div class="array__bracket array__bracket--last">]</div>
                                <div id="enqueue-idx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">idx</div>
                                </div>
                                <div id="enqueue-parentIdx" class="array__pointer">
                                    <div class="array__pointer-label">parentIdx</div>
                                </div>
                            </div>
                        </div>
                        <div class="code-box__tree code-box__tree--smaller-height-with-additional-space-for-pointer">
                            <div id="priority-queue-1" class="tree"></div>
                        </div>
                    </div>
                    <h2 class="heading-secondary u-mb-tiny">Metoda dequeue</h2>
                    <p class="paragraph u-mb-small">Pro odstranění a získání položky z PriorityQueue si vytvoříme metodu dequeue. Bude stejná jako metoda extractMax, kterou jsme si vytvořili pro Max Binary Heap. Rozdíl bude jen v metodě sinkDown, kterou metoda dequeue volá. Narozdíl od hodnot položek v poli values se bude porovnávat jejich priorita.</p>
                    <div data-interactive-example-id="4" class="code-box u-mb-small">
                        <div class="code-box__header">
                            <div class="code-box__icon">
                                <svg>
                                    <use xlink:href="../media/img/icon-sprite.svg#icon-cogs"></use>
                                </svg>
                            </div>
                            <div class="code-box__buttons-container">
                                <button class="code-box__button code-box__button--move"
                                    data-interactive-example-move-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-forward3"></use>
                                    </svg>
                                </button>
                                <select class="code-box__speed-input" data-interactive-example-speed-input="true">
                                    <option value="0.25">0.25</option>
                                    <option value="0.5">0.5</option>
                                    <option value="0.75">0.75</option>
                                    <option selected value="1">1</option>
                                    <option value="1.25">1.25</option>
                                    <option value="1.5">1.5</option>
                                    <option value="1.75">1.75</option>
                                </select>
                                <button class="code-box__button" data-interactive-example-play-button="true">
                                    <span>
                                        <svg>
                                            <use xlink:href="../media/img/icon-sprite.svg#icon-play3"></use>
                                        </svg>
                                    </span>
                                </button>
                                <button class="code-box__button code-box__button--reset"
                                    data-interactive-example-reset-button="true">
                                    <svg>
                                        <use xlink:href="../media/img/icon-sprite.svg#icon-loop2"></use>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <pre id="code-4" class="code-box__code code-box__code--max-height"><code>class PriorityQueue {
    /* ... */

    // metoda pro odstranění a získání položky z Priority Queue
    dequeue() {
        const max = this.values[0];
        const end = this.values.pop();
        if (this.values.length > 0) {
            this.values[0] = end;
            this.sinkDown();
        }
        return max;
    }

    // tato metoda přemístí první (root) hodnotu v poli values na správné místo
    // (aby měli potomci v Priority Queue menší prioritu než jejich předek)
    sinkDown() {
        let idx = 0;
        const length = this.values.length;
        const element = this.values[0];

        while (true) {
            let leftChildIdx = 2 * idx + 1;
            let rightChildIdx = 2 * idx + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIdx &lt; length) {
                leftChild = this.values[leftChildIdx];
                // v Priority Queue porovnáváme priority, hodnoty ne
                if (leftChild.priority &gt; element.priority) {
                    swap = leftChildIdx;
                }
            }
            if (rightChildIdx &lt; length) {
                rightChild = this.values[rightChildIdx];
                // v Priority Queue porovnáváme priority, hodnoty ne
                if (
                    (swap === null && rightChild.priority &gt; element.priority) ||
                    (swap !== null && rightChild.priority &gt; leftChild.priority)
                ) {
                    swap = rightChildIdx;
                }
            }

            if (swap === null) break;
            this.values[idx] = this.values[swap];
            this.values[swap] = element;
            idx = swap;
        }
    }
}

// vytvoření Priority Queue
const queue = new PriorityQueue();

// vložení položek do Priority Queue
queue.enqueue(45, 3);
queue.enqueue(23, 4);
queue.enqueue(33, 2);
queue.enqueue(46, 6);
queue.enqueue(18, 2);
queue.enqueue(14, 7);
queue.enqueue(22, 1);

// získání položek z Priority Queue
const polozka1 = queue.dequeue();
const položka2 = queue.dequeue();
const polozka3 = queue.dequeue();
</code></pre>
                        <div class="code-box__array">
                            <div id="visual-array-dequeue" class="array array--bigger-top-padding">
                                <div class="array__variables" style="position: relative;"><span style="white-space: nowrap; position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);"><div id="variable-dequeue-max" class="array__variable"><span>max: </span><span>0</span></div><div id="variable-dequeue-end" class="array__variable"><span>end: </span><span>0</span></div><div id="variable-dequeue-element" class="array__variable"><span>element: </span><span>0</span></div><div id="variable-dequeue-leftChild" class="array__variable"><span>leftChild: </span><span>undefined</span></div><div id="variable-dequeue-rightChild" class="array__variable"><span>rightChild: </span><span>undefined</span></div><div id="variable-dequeue-swap" class="array__variable"><span>swap: </span><span>null</span></div></span></div>
                                <div class="array__bracket array__bracket--first">[</div><div class="array__item-container"></div><div class="array__bracket array__bracket--last">]</div>
                                <div id="dequeue-idx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">idx</div>
                                </div>
                                <div id="dequeue-leftChildIdx" class="array__pointer">
                                    <div class="array__pointer-label">leftChildIdx</div>
                                </div>
                                <div id="dequeue-rightChildIdx" class="array__pointer array__pointer--bottom">
                                    <div class="array__pointer-label">rightChildIdx</div>
                                </div>
                            </div>
                        </div>
                        <div class="code-box__tree code-box__tree--smaller-height-with-additional-space-for-pointer">
                            <div id="priority-queue-2" class="tree"></div>
                        </div>
                    </div>
                    <p class="paragraph u-mb-medium">Je tu jedna věc, na kterou bych vás měl upozornit. Pokud mají dvě položky v Priority Queue stejnou prioritu, tak není zaručené, že položku, kterou jsme do Priority Queue přidali jako první, také získáme jako první. Pokud bychom to chtěli napravit, tak bychom kromě priority mohli do node ukládat také například čas, kdy jsme položku do Priority Queue vložili. Tento čas bychom potom porovnávali společně s prioritami. Záleží na nás podle čeho chceme položky porovnávat. Můžeme mít klidně více kritérií, záleží na co konkrétně chceme Priority Queue použít.</p>
                    <h2 class="heading-secondary u-mb-tiny">Big O náročnost Binary Heap</h2>
                    <p class="paragraph u-mb-small">Na závěr si ukážeme časovou náročnost některých operací s Binary Heap.</p>
                    <ul class="unordered-list">
                        <li><b>přidávání položek:</b> O(log n)</li>
                        <li><b>odstraňování položek:</b> O(log n)</li>
                        <li><b>hledání položek:</b> O(n)</li>
                    </ul>
                </main>
                <div class="article-page__lateral-side">
                    <div class="article-page__sticky-content">
                        <h2 class="heading-secondary u-mb-small">Části Tutoriálu</h2>
                        <nav class="navigation">
                            <ul>
                                <li class="navigation__item"><a href="../big-o-notation/" class="navigation__link"><span>1.</span>Big O Notation</a></li>
                                <li class="navigation__item"><a href="../postup-pri-reseni-problemu/" class="navigation__link"><span>2.</span>Postup při řešení problému</a></li>
                                <li class="navigation__item"><a href="../rekurze/" class="navigation__link"><span>3.</span>Rekurze</a></li>
                                <li class="navigation__item"><a href="../vyhledavaci-algoritmy/" class="navigation__link"><span>4.</span>Vyhledávací algoritmy</a></li>
                                <li class="navigation__item"><a href="../serazovaci-algoritmy/" class="navigation__link"><span>5.</span>Seřazovací algoritmy</a></li>
                                <li class="navigation__item"><a href="../singly-linked-list/" class="navigation__link"><span>6.</span>Singly Linked List</a></li>
                                <li class="navigation__item"><a href="../doubly-linked-list/" class="navigation__link"><span>7.</span>Doubly Linked List</a></li>
                                <li class="navigation__item"><a href="../stack-a-queue/" class="navigation__link"><span>8.</span>Stack a Queue</a></li>
                                <li class="navigation__item"><a href="../binary-search-tree/" class="navigation__link"><span>9.</span>Binary Search Tree</a></li>
                                <li class="navigation__item"><a href="../tree-traversing/" class="navigation__link"><span>10.</span>Tree Traversing</a></li>
                                <li class="navigation__item"><a href="../binary-heap/" class="navigation__link navigation__link--active"><span>11.</span>Binary Heap</a></li>
                                <li class="navigation__item"><a href="../hash-table/" class="navigation__link"><span>12.</span>Hash Table</a></li>
                                <li class="navigation__item"><a href="../graph/" class="navigation__link"><span>13.</span>Graph</a></li>
                                <li class="navigation__item"><a href="../graph-traversing/" class="navigation__link"><span>14.</span>Graph Traversing</a></li>
                                <li class="navigation__item"><a href="../dijkstruv-algoritmus/" class="navigation__link"><span>15.</span>Dijkstrův algoritmus</a></li>
                                <li class="navigation__item"><a href="../dynamicke-programovani/" class="navigation__link"><span>16.</span>Dynamické programování</a></li>
                            </ul>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
        <footer class="footer">
            Copyright &copy; by Jiří Satora
        </footer>
    </div>

    <script type="module" src="../media/js/parts/binaryHeap.js"></script>
</body>
</html>